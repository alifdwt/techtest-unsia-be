// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: attempt.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const countUserAttempts = `-- name: CountUserAttempts :one
SELECT COUNT(*)
FROM quiz_attempts
WHERE quiz_id = $1
  AND user_id = $2
`

type CountUserAttemptsParams struct {
	QuizID pgtype.UUID `json:"quiz_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) CountUserAttempts(ctx context.Context, arg CountUserAttemptsParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUserAttempts, arg.QuizID, arg.UserID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createQuizAttempt = `-- name: CreateQuizAttempt :one
INSERT INTO quiz_attempts (
  quiz_id,
  user_id,
  attempt_number,
  started_at,
  status
) VALUES (
  $1, $2, $3, now(), 'in_progress'
)
RETURNING id, quiz_id, user_id, attempt_number, started_at, finished_at, status
`

type CreateQuizAttemptParams struct {
	QuizID        pgtype.UUID `json:"quiz_id"`
	UserID        pgtype.UUID `json:"user_id"`
	AttemptNumber int32       `json:"attempt_number"`
}

func (q *Queries) CreateQuizAttempt(ctx context.Context, arg CreateQuizAttemptParams) (QuizAttempt, error) {
	row := q.db.QueryRow(ctx, createQuizAttempt, arg.QuizID, arg.UserID, arg.AttemptNumber)
	var i QuizAttempt
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.UserID,
		&i.AttemptNumber,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
	)
	return i, err
}

const getActiveAttempt = `-- name: GetActiveAttempt :one
SELECT id, quiz_id, user_id, attempt_number, started_at, finished_at, status
FROM quiz_attempts
WHERE quiz_id = $1
  AND user_id = $2
  AND status = 'in_progress'
ORDER BY started_at DESC
LIMIT 1
`

type GetActiveAttemptParams struct {
	QuizID pgtype.UUID `json:"quiz_id"`
	UserID pgtype.UUID `json:"user_id"`
}

func (q *Queries) GetActiveAttempt(ctx context.Context, arg GetActiveAttemptParams) (QuizAttempt, error) {
	row := q.db.QueryRow(ctx, getActiveAttempt, arg.QuizID, arg.UserID)
	var i QuizAttempt
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.UserID,
		&i.AttemptNumber,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
	)
	return i, err
}

const getAttemptByID = `-- name: GetAttemptByID :one
SELECT id, quiz_id, user_id, attempt_number, started_at, finished_at, status
FROM quiz_attempts
WHERE id = $1
`

func (q *Queries) GetAttemptByID(ctx context.Context, id pgtype.UUID) (QuizAttempt, error) {
	row := q.db.QueryRow(ctx, getAttemptByID, id)
	var i QuizAttempt
	err := row.Scan(
		&i.ID,
		&i.QuizID,
		&i.UserID,
		&i.AttemptNumber,
		&i.StartedAt,
		&i.FinishedAt,
		&i.Status,
	)
	return i, err
}

const getQuizDurationByAttemptID = `-- name: GetQuizDurationByAttemptID :one
SELECT q.duration_seconds
FROM quizzes q
JOIN quiz_attempts qa ON qa.quiz_id = q.id
WHERE qa.id = $1
`

func (q *Queries) GetQuizDurationByAttemptID(ctx context.Context, id pgtype.UUID) (int32, error) {
	row := q.db.QueryRow(ctx, getQuizDurationByAttemptID, id)
	var duration_seconds int32
	err := row.Scan(&duration_seconds)
	return duration_seconds, err
}

const updateAttemptStatus = `-- name: UpdateAttemptStatus :exec
UPDATE quiz_attempts
SET status = $2,
    finished_at = CASE
      WHEN $2 IN ('submitted', 'waiting_assessment', 'graded')
      THEN now()
      ELSE finished_at
    END
WHERE id = $1
`

type UpdateAttemptStatusParams struct {
	ID     pgtype.UUID `json:"id"`
	Status string      `json:"status"`
}

func (q *Queries) UpdateAttemptStatus(ctx context.Context, arg UpdateAttemptStatusParams) error {
	_, err := q.db.Exec(ctx, updateAttemptStatus, arg.ID, arg.Status)
	return err
}
